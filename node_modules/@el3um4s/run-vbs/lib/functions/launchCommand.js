"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.launchCommand = void 0;
const node_child_process_1 = require("node:child_process");
const buffer_1 = require("buffer");
const isEmpty = (object) => Object.keys(object).length === 0;
const exitMessages = {
    1: "Uncaught Fatal Exception",
    3: "Internal JavaScript Parse Error",
    4: "Internal JavaScript Evaluation Failure",
    5: "Fatal Error",
    6: "Non-function Internal Exception Handler",
    7: "Internal Exception Handler Run-Time Failure",
    9: "Invalid Argument",
    10: "Internal JavaScript Run-Time Failure",
    12: "Invalid Debug Argument",
};
const launchCommand = (cmd) => {
    const { command, args, options, input } = cmd;
    return new Promise((resolve, reject) => {
        const encoding = "utf8";
        const stderrOutput = [];
        const errors = Object.create(null);
        const child = (0, node_child_process_1.spawn)(command, args, Object.assign({ windowsHide: true }, options));
        child.on("error", (error) => (errors.spawn = error));
        child.stdin.on("error", (error) => (errors.stdin = error));
        child.stdout.on("error", (error) => (errors.stdout = error));
        child.stderr.on("error", (error) => (errors.stderr = error));
        child.stderr.on("data", (data) => stderrOutput.push(data));
        const result = [];
        child.stdout.on("data", (data) => {
            result.push(data);
        });
        child.on("close", (exitCode) => {
            if (exitCode !== 0 && exitCode != null) {
                errors.exitMessage = exitMessages[exitCode];
            }
            if (stderrOutput.length) {
                errors.process = buffer_1.Buffer.concat(stderrOutput).toString(encoding);
            }
            if (!isEmpty(errors)) {
                errors.exitCode = exitCode;
                return reject(Object.assign(new Error(`Spawn ${command} error`), errors));
            }
            return resolve(result.join(""));
        });
        child.stdin.end(input, encoding);
    });
};
exports.launchCommand = launchCommand;
